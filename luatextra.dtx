% \iffalse meta-comment
%
% Copyright (C) 2009 by Elie Roux <elie.roux@telecom-bretagne.eu>
%
% This work is under the CC0 license.
%
% This work consists of the main source file luamcallbacks.dtx
% and the derived files
%    luatextra.sty, luatextra.lua, luatextra-latex.tex, luatextra.pdf.
%
% Unpacking:
%    tex luatextra.dtx
%
% Documentation:
%    pdflatex luatextra.dtx
%
%    The class ltxdoc loads the configuration file ltxdoc.cfg
%    if available. Here you can specify further options, e.g.
%    use A4 as paper format:
%       \PassOptionsToClass{a4paper}{article}
%
%
%
%<*ignore>
\begingroup
  \def\x{LaTeX2e}%
\expandafter\endgroup
\ifcase 0\ifx\install y1\fi\expandafter
         \ifx\csname processbatchFile\endcsname\relax\else1\fi
         \ifx\fmtname\x\else 1\fi\relax
\else\csname fi\endcsname
%</ignore>
%<*install>
\input docstrip.tex
\Msg{************************************************************************}
\Msg{* Installation}
\Msg{* Package: luatextra 2009/12/04 v0.95 Extra low level functions for LuaTeX}
\Msg{************************************************************************}

\keepsilent
\askforoverwritefalse

\let\MetaPrefix\relax

\preamble
This is a generated file.

Copyright (C) 2009 by Elie Roux <elie.roux@telecom-bretagne.eu>

This work is under the CC0 license.

This work consists of the main source file luainputenc.dtx
and the derived files
    luatextra.sty, luatextra.lua, luatextra-latex.tex, luatextra.pdf

\endpreamble

\let\MetaPrefix\DoubleperCent


\generate{%
  \usedir{tex/luatex/luatextra}%
  \file{luatextra.sty}{\from{luatextra.dtx}{package}}%
  \file{luatextra-latex.tex}{\from{luatextra.dtx}{latex}}%
}

% The following hacks are to generate a lua file with lua comments starting by
% -- instead of %%

\def\MetaPrefix{-- }

\def\luapostamble{%
  \MetaPrefix^^J%
  \MetaPrefix\space End of File `\outFileName'.%
}

\def\currentpostamble{\luapostamble}%

\generate{%
  \usedir{tex/luatex/luatextra}%
  \file{luatextra.lua}{\from{luatextra.dtx}{lua}}%%
}

\obeyspaces
\Msg{************************************************************************}
\Msg{*}
\Msg{* To finish the installation you have to move the following}
\Msg{* files into a directory searched by TeX:}
\Msg{*}
\Msg{*     luatextra.sty luatextra-latex.tex luatextra.lua}
\Msg{*}
\Msg{* Happy TeXing!}
\Msg{*}
\Msg{************************************************************************}

\endbatchfile
%</install>
%<*ignore>
\fi
%</ignore>
%<*driver>
\NeedsTeXFormat{LaTeX2e}
\ProvidesFile{luaminimalotf.drv}%
  [2009/12/04 v0.95 LuaTeX extra low-level macros.]%
\documentclass{ltxdoc}
\EnableCrossrefs
\CodelineIndex
\begin{document}
  \DocInput{luatextra.dtx}%
\end{document}
%</driver>
% \fi
%
% \CheckSum{0}
%
% \CharacterTable
%  {Upper-case    \A\B\C\D\E\F\G\H\I\J\K\L\M\N\O\P\Q\R\S\T\U\V\W\X\Y\Z
%   Lower-case    \a\b\c\d\e\f\g\h\i\j\k\l\m\n\o\p\q\r\s\t\u\v\w\x\y\z
%   Digits        \0\1\2\3\4\5\6\7\8\9
%   Exclamation   \!     Double quote  \"     Hash (number) \#
%   Dollar        \$     Percent       \%     Ampersand     \&
%   Acute accent  \'     Left paren    \(     Right paren   \)
%   Asterisk      \*     Plus          \+     Comma         \,
%   Minus         \-     Point         \.     Solidus       \/
%   Colon         \:     Semicolon     \;     Less than     \<
%   Equals        \=     Greater than  \>     Question mark \?
%   Commercial at \@     Left bracket  \[     Backslash     \\
%   Right bracket \]     Circumflex    \^     Underscore    \_
%   Grave accent  \`     Left brace    \{     Vertical bar  \|
%   Right brace   \}     Tilde         \~}
%
% \GetFileInfo{luatextra.drv}
%
% \title{The \textsf{luatextra} package}
% \date{2009/12/04 v0.95}
% \author{Elie Roux \\ \texttt{elie.roux@telecom-bretagne.eu}}
%
% \maketitle
%
% \begin{abstract}
% \textsf{luatextra} provides low-level addition to the formats Plain and
% \LaTeX\ to be used with the engine Lua\TeX.
% \end{abstract}
%
% \tableofcontents
%
% \section{Documentation}
%
% \subsection{Preamble}
%
% This document is made for people wanting to understand how the package was
% made. For an introduction to the use of Lua\TeX\ with the formats Plain and
% \LaTeX , please read the document \texttt{luatextra-reference.pdf} that you
% can find in your \TeX\ distribution (\TeX Live from version 2009) or on the
% CTAN.
%
% \subsection{History of formats and engines}
%
% To understand this package, one must fist understand some historical choices
% in the \TeX\ world.
%
% A \TeX\ engine is a binary executable that provides some very low-level
% primitives, for example \texttt{\string\count} to set a counter to a certain
% value. A \TeX\ format is a macro package that provides higher-level macros
% for the user and the package developer, for example
% \texttt{\string\newcount} that allocates a new counter and gives it a name.
% Examples of engines are the old \TeX\ 82, $\varepsilon$-\TeX, pdf\TeX,
% Omega/Aleph, Lua\TeX\ and Xe\TeX. Examples of formats are Plain, \LaTeX\ and
% Con\TeX t.
%
% This distinction is hard to make as only one command is invoked, for example
% when you call the command \texttt{tex}, you often have no idea that the
% engine \TeX\ 82 is invoked with the format Plain.
%
% Evolution is also something confusing in the \TeX\ world: engines often
% evolve, and new engines have always appeared, when most formats are frozen:
% the Plain and \LaTeX\ formats do not accept any new code to cope with the
% new engines. In theory, this package shouldn't exist, or at least shouldn't
% be a package, but its code should be integrated into a format. But as Plain
% and \LaTeX\ are frozen, people wanting to take advantage of the new engines
% have to use a package.
%
% This package is really necessary to take advantage of Lua\TeX\ as it
% provides things users are expecting a macro package to provide, for example
% \texttt{\string\newluaattribute} that acts like \texttt{\string\newcount}
% for lua attributes. It also enables all Lua\TeX\ primitives, that are
% disabled by default.
%
% \subsection{choices made in this package}
%
% In the very long term, it is higly possible that Lua\TeX\ will replace
% pdf\TeX\ as the default \LaTeX\ engine, so it is necessary to keep backward
% compatibility. This lead us to the decision of renaming Lua\TeX -only
% primitives so that they all start by \texttt{luatex}, like the pdf\TeX -only
% primitives start by \texttt{pdf}. Thus attributes become luatexattributes,
% etc. This % also allows primitives to keep having the same name, even if their
% name is changed later at the engine level. Also some new functions like
% \texttt{newluatexattribute} are provided with the \texttt{lua} prefix, to
% shorten the already too long name.
%
% \subsection{registers allocation scheme}
%
% The default register allocation scheme of \LaTeX\ is old and limited (like
% the one of \TeX 82) to 256 values. The engine $\varepsilon$-\TeX allows more
% different registers (up to 32768), and Lua\TeX\ allows even 65536 ones.
% These new limits were not acknowledged by \LaTeX . A package \textsf{etex}
% was created for \LaTeX\ to extends the allocation scheme. \textsf{luatextra}
% loads \textsf{etex}, and overrides somes values to extend the allocation max
% number to 65536.
%
% \subsection{attributes}
%
% Attributes are a new concept in Lua\TeX\ (see the Lua\TeX\ documentation for
% details). As the macro \texttt{\string\attribute} is certainly very common
% in the user's documents, they are renamed \texttt{luaattribute}s. This
% package provides a simple way to allocate new attributes, with the macro
% \texttt{\string\newluaattribute}. For more informations about attribute
% handling in lua, please read section \ref{sub:attr}.
%
% \subsection{Module system}
%
% Lua has some embedded module management, with the functions \texttt{module}
% and \texttt{require}. With this package we try get more control on the
% module system, by implementing something close to the \LaTeX 's
% \texttt{\string\usepackage} and \texttt{\string\RequirePackage} macros: the
% \texttt{\string\luatexUseModule} and \texttt{\string\luatexRequireModule} that act
% like them, but for lua files. The functions \texttt{module} and
% \texttt{require} should not be used, in profit of the lua functions
% \texttt{luatextra.provides\_module} and \texttt{luatextra.use\_module} or
% \texttt{luatextra.require\_module}.
%
% \subsection{Multiple callbacks handling}
%
% Lua\TeX\ has no way to register multiple functions in a callback. This
% package loads \textsf{luamcallbacks} that provides a safe way to do so. But
% the \textsf{luamcallbacks} package can't register several functions in some
% callbacks, like \texttt{open\_read\_file} and \texttt{define\_font}. This
% package takes advantage of the callback creation possibilities of
% \textsf{luamcallbacks} to split these callbacks into several ones that can
% agregate several functions. Thus it allows several packages to safely use
% the callbacks. See section \ref{sub:orf} for more details.
%
% \section{\texttt{luatextra.lua}}
%
% \subsection{Initialization and internal functions}
%
% \iffalse
%<*lua>
% \fi
%
%    \TeX\ always prints the names of the files that are input. Unfortunatly
%    it can't do so with lua files called with \texttt{dofile}. We will fix it
%    with the \texttt{luatextra.use\_module} function, but in the meantime we
%    print this information for the \texttt{luatextra.lua} file.
%
%    A change compared to usual filename printings is the fact that Lua\TeX\
%    does not print the \texttt{./} for files in the current directory. We
%    keep this convention for lua filename printings.
%
%    \begin{macrocode}
do
    local luatextrapath = kpse.find_file("luatextra.lua")
    if luatextrapath then
        if luatextrapath:sub(1,2) == "./" then
            luatextrapath = luatextrapath:sub(3)
        end
        texio.write_nl('('..luatextrapath)
    end
end

%    \end{macrocode}
%
%    We create the \texttt{luatextra} table that will contain all the
%    functions and variables, and we register it as a normal lua module.
%
%    \begin{macrocode}

luatextra = {}

module("luatextra", package.seeall)

%    \end{macrocode}
%
%    We initiate the modules table that will contain informations about the
%    loaded modules. And we register the \texttt{luatextra} module. The
%    informations contained in the table describing the module are always the
%    same, it can be taken as a template. See
%    \texttt{luatextra.provides\_module} for more details.
%
%    \begin{macrocode}

luatextra.modules = {}

luatextra.modules['luatextra'] = {
    version     = 0.95,
    name        = "luatextra",
    date        = "2009/12/04",
    description = "Additional low level functions for LuaTeX",
    author      = "Elie Roux",
    copyright   = "Elie Roux, 2009",
    license     = "CC0",
}

local format = string.format

%    \end{macrocode}
%
%    Here we define the warning and error functions specific to
%    \texttt{luatextra}.
%
%    \begin{macrocode}

luatextra.internal_warning_spaces = "                   "

function luatextra.internal_warning(msg)
    if not msg then return end
    texio.write_nl(format("\nLuaTeXtra Warning: %s\n\n", msg))
end

luatextra.internal_error_spaces = "                 "

function luatextra.internal_error(msg)
    if not msg then return end
    tex.sprint(format("\\immediate\\write16{}\\errmessage{LuaTeXtra error: %s^^J^^J}", msg))
end

%    \end{macrocode}
%
% \subsection{Error, warning and info function for modules}
%
%    Some module printing functions are provided, they have the same
%    philosophy as the \LaTeX 's \texttt{\string\PackageError} and
%    \texttt{\string\PackageWarning} macros: their first argument is the name
%    of the module, and the second is the message. These functions are meant
%    to be used by lua module writers.
%
%    \begin{macrocode}

function luatextra.module_error(package, msg, helpmsg)
    if not package or not msg then
        return
    end
    if helpmsg then
        tex.sprint(format("\\errhelp{%s}", helpmsg))
    end
    tex.sprint(format("\\luatexModuleError{%s}{%s}", package, msg))
end

function luatextra.module_warning(modulename, msg)
    if not modulename or not msg then
        return
    end
    texio.write_nl(format("\nModule %s Warning: %s\n\n", modulename, msg))
end

function luatextra.module_log(modulename, msg)
    if not modulename or not msg then
        return
    end
    texio.write_nl('log', format("%s: %s", modulename, msg))
end

function luatextra.module_term(modulename, msg)
    if not modulename or not msg then
        return
    end
    texio.write_nl('term', format("%s: %s", modulename, msg))
end

function luatextra.module_info(modulename, msg)
    if not modulename or not msg then
        return
    end
    texio.write_nl(format("%s: %s\n", modulename, msg))
end

%    \end{macrocode}
%
%    \subsection{module loading and providing functions}
%
%    A small function to find a lua module file according to its name, with or
%    without the \texttt{.lua} at the end of the filename.
%
%    \begin{macrocode}

function luatextra.find_module_file(name)
    if string.sub(name, -4) ~= '.lua' then
        name = name..'.lua'
    end
    path = kpse.find_file(name, 'tex')
    if not path then
      path = kpse.find_file(name, 'texmfscripts')
    end
    return path, name
end

%    \end{macrocode}
%
%    A small patch, for the \texttt{module} function to work in this file. I
%    can't understand why it doens't otherwise.
%
%    \begin{macrocode}

luatextra.module = module

%    \end{macrocode}
%
%    \begin{macro}{luatextra.use module}
%
%    This macro is the one used to simply load a lua module file. It does not
%    reload it if it's already loaded, and prints the filename in the terminal
%    and the log. A lua module must call the macro
%    \texttt{luatextra.provides\_module}.
%
%    \begin{macrocode}


function luatextra.use_module(name)
    if not name or luatextra.modules[name] then
        return
    end
    local path, filename = luatextra.find_module_file(name)
    if not path then
        luatextra.internal_error(format("unable to find lua module %s", name))
    else
        if path:sub(1,2) == "./" then
            path = path:sub(3)
        end
        texio.write_nl('('..path)
        dofile(path)
        if not luatextra.modules[name] then
            luatextra.internal_warning(format("You have requested module `%s',\n%s but the file %s does not provide it.", name, luatextra.internal_warning_spaces, filename))
        end
        if not package.loaded[name] then
            luatextra.module(name, package.seeall)
        end
        texio.write(')')
    end
end

%    \end{macrocode}
%
%    \end{macro}
%
%    Some internal functions to convert a date into a number, and to determine
%    if a string is a date. It is useful for
%    \texttt{luatextra.require\_package} to understand if a user asks a
%    version with a date or a version number.
%
%    \begin{macrocode}

function luatextra.datetonumber(date)
    numbers = string.gsub(date, "(%d+)/(%d+)/(%d+)", "%1%2%3")
    return tonumber(numbers)
end

function luatextra.isdate(date)
    for _, _ in string.gmatch(date, "%d+/%d+/%d+") do
        return true
    end
    return false
end

local date, number = 1, 2

function luatextra.versiontonumber(version)
    if luatextra.isdate(version) then
        return {type = date, version = luatextra.datetonumber(version), orig = version}
    else
        return {type = number, version = tonumber(version), orig = version}
    end
end

luatextra.requiredversions = {}

%    \end{macrocode}
%
%    \begin{macro}{luatextra.require module}
%
%    This function is like the \texttt{luatextra.use\_module} function, but
%    can accept a second argument that checks for the version of the module.
%    The version can be a number or a date (format yyyy/mm/dd).
%
%    \begin{macrocode}

function luatextra.require_module(name, version)
    if not name then
        return
    end
    if not version then
        return luatextra.use_module(name)
    end
    luaversion = luatextra.versiontonumber(version)
    if luatextra.modules[name] then
        if luaversion.type == date then
            if luatextra.datetonumber(luatextra.modules[name].date) < luaversion.version then
                luatextra.internal_error(format("found module `%s' loaded in version %s, but version %s was required", name, luatextra.modules[name].date, version))
            end
        else
            if luatextra.modules[name].version < luaversion.version then
                luatextra.internal_error(format("found module `%s' loaded in version %.02f, but version %s was required", name, luatextra.modules[name].version, version))
            end
        end
    else
        luatextra.requiredversions[name] = luaversion
        luatextra.use_module(name)
    end
end

%    \end{macrocode}
%
%    \end{macro}
%
%    \begin{macro}{luatextra.provides module}
%
%    This macro is the one that must be called in the module files. It takes a
%    table as argument. You can put any information you want in this table,
%    but the mandatory ones are \texttt{name} (a string), \texttt{version} (a
%    number), \texttt{date} (a string) and \texttt{description} (a string).
%    Other fields are usually \texttt{copyright}, \texttt{author} and
%    \texttt{license}.
%
%    This function logs informations about the module the same way \LaTeX\
%    does for informations about packages.
%
%    \begin{macrocode}

function luatextra.provides_module(mod)
    if not mod then
        luatextra.internal_error('cannot provide nil module')
        return
    end
    if not mod.version or not mod.name or not mod.date or not mod.description then
        luatextra.internal_error('invalid module registered, fields name, version, date and description are mandatory')
        return
    end
    requiredversion = luatextra.requiredversions[mod.name]
    if requiredversion then
        if requiredversion.type == date and requiredversion.version > luatextra.datetonumber(mod.date) then
            luatextra.internal_error(format("loading module %s in version %s, but version %s was required", mod.name, mod.date, requiredversion.orig))
        elseif requiredversion.type == number and requiredversion.version > mod.version then
            luatextra.internal_error(format("loading module %s in version %.02f, but version %s was required", mod.name, mod.version, requiredversion.orig))
        end
    end
    luatextra.modules[mod.name] = module
    texio.write_nl('log', format("Lua module: %s %s v%.02f %s\n", mod.name, mod.date, mod.version, mod.description))
end

%    \end{macrocode}
%
%    \end{macro}
%
%    Here we load the \textsf{luaextra} module, that contains a bunch of very
%    useful functions. See the documentation of \textsf{luaextra} for more
%    details.
%
%    \begin{macrocode}

luatextra.use_module('luaextra')

%    \end{macrocode}
%
%    \texttt{luatextra.kpse\_module\_loader} finds a module with the
%    \texttt{kpse} library. This function is then registered in the table of
%    the functions used by the lua function \texttt{require} to look for
%    modules.
%
%    \begin{macrocode}

function luatextra.kpse_module_loader(mod)
  local file = luatextra.find_module_file(mod)
  if file then
    local loader, error = loadfile(file)
    if loader then
      texio.write_nl("(" .. file .. ")")
      return loader
    end
    return "\n\t[luatextra.kpse_module_loader] Loading error:\n\t"
           .. error
  end
  return "\n\t[luatextra.kpse_module_loader] Search failed"
end

table.insert(package.loaders, luatextra.kpse_module_loader)

%    \end{macrocode}
%
%    \subsection{Attributes handling\label{sub:attr}}
%
%    Attribute allocation is done mainly in the \texttt{sty} file, but there
%    is also a lua addition for attribute handling: Lua\TeX\ is by default
%    unable to tell the attribute number corresponding to an attribute name.
%    This attribute number is necessary for functions such as
%    \texttt{node.has\_attribute}, which is used very often. The solution
%    until now was to give a chosen attribute number to each attribute, and
%    pray that someone else didn't use it before. With this method it was easy
%    to know the number of an attribute, as it was chosen. Now with the
%    \texttt{\string\newluaattribute} macro, it's impossible to know the
%    number of an attribute. To fix it, when \texttt{\string\newluaattribute}
%    is called, it calls \texttt{luatextra.attributedef\_from\_tex}. This
%    function registers the number in the table \texttt{tex.attributenumber}.
%    For example to get the number of the attribute \texttt{myattribute}
%    registered with \texttt{\string\newluaattribute\string\myattribute}, you
%    can simply call \texttt{tex.attributenumber[myattribute]}.
%
%    \begin{macrocode}

luatextra.attributes = {}

tex.attributenumber = luatextra.attributes

function luatextra.attributedef_from_tex(name, number)
    truename = name:gsub('[\\ ]', '')
    luatextra.attributes[truename] = tonumber(number)
end

%    \end{macrocode}
%
% \subsection{Catcodetables handling}
%
%    In the same way, the table \texttt{tex.catcodetablenumber} contains the
%    numbers of the catcodetables registered with
%    \texttt{\string\newluacatcodetable}.
%
%    \begin{macrocode}

luatextra.catcodetables = {}

tex.catcodetablenumber = luatextra.catcodetables

function luatextra.catcodetabledef_from_tex(name, number)
    truename = name:gsub('[\\ ]', '')
    luatextra.catcodetables[truename] = tonumber(number)
end

%    \end{macrocode}
%
%    With this function we create some shortcuts for a
%    better readability in lua code. This makes
%    |tex.catcodenumber.latex| equivalent to 
%    |tex.catcodenumber['CatcodeTableLaTeX']|.
%
%    \begin{macrocode}

function luatextra.catcodetable_do_shortcuts()
    local cat = tex.catcodetablenumber
    local val = cat['CatcodeTableLaTeX']
    if val then
      cat['latex'] = val
    end
    val = cat['CatcodeTableLaTeXAtLetter']
    if val then
      cat['latex-package'] = val
      cat['latex-makeatletter'] = val
    end
    val = cat['CatcodeTableIniTeX']
    if val then
      cat['ini'] = val
    end
    val = cat['CatcodeTableExpl']
    if val then
      cat['expl3'] = val
      cat['expl'] = val
    end
    val = cat['CatcodeTableString']
    if val then
      cat['string'] = val
    end
    val = cat['CatcodeTableOther']
    if val then
      cat['other'] = val
    end
end

%    \end{macrocode}
%
%    \subsection{Multiple callbacks on the \texttt{open\_read\_file}
%    callback\label{sub:orf}}
%
%    The luamcallbacks (see documentation for details) cannot really provide a
%    simple and reliable way of registering multiple functions in some
%    callbacks. To be able to do so, the solution we implemented is to
%    register one function in these callbacks, and to create "sub-callbacks"
%    that can accept several functions. That's what we do here for the
%    callback \texttt{open\_read\_file}.
%
%    \begin{macro}{luatextra.open read file}
%
%    This function is the one that will be registered in the callback. It
%    calls new callbacks, that will be created later. These callbacks are:
%
%    \begin{itemize}
%    \item \texttt{pre\_read\_file} in which you can register a function with
%    the signature \texttt{pre\_read\_file(env)}, with \texttt{env} being a
%    table containing the fields \texttt{filename} which is the argument of
%    the callback \texttt{open\_read\_file}, and \texttt{path} which is the
%    result of \texttt{kpse.find\_file}. You can put any field you want in the
%    \texttt{env} table, you can even override the existing fields. This
%    function is called at the very beginning of the callback, it allows for
%    instance to register functions in the other callbacks. It is useless to
%    add a field \texttt{reader} or \texttt{close}, as they will be overriden.
%    \item \texttt{file\_reader} is automatically registered in the
%    \texttt{reader} callback for every file, it has the same signature.
%    \item \texttt{file\_close} is registered in the \texttt{close} callback
%    for every file, and has the same signature.
%    \end{itemize}
%
%    \begin{macrocode}

function luatextra.open_read_file(filename)
    local path = kpse.find_file(filename)
    local env = {
      ['filename'] = filename,
      ['path'] = path,
    }
    luamcallbacks.call('pre_read_file', env)
    path = env.path
    if not path then
        return
    end
    local f = env.file
    if not f then
        f = io.open(path)
        env.file = f
    end
    if not f then
        return
    end
    env.reader = luatextra.reader
    env.close = luatextra.close
    return env
end

%    \end{macrocode}
%
% \end{macro}
%
%    The two next functions are the one called in the
%    \texttt{open\_read\_file} callback.
%
%    \begin{macrocode}

function luatextra.reader(env)
    local line = (env.file):read()
    line = luamcallbacks.call('file_reader', env, line)
    return line
end

function luatextra.close(env)
    (env.file):close()
    luamcallbacks.call('file_close', env)
end

%    \end{macrocode}
%
%    In the callback creation process we need to have default behaviours. Here
%    they are. These are called only when no function is registered in the
%    created callback. See the documentation of \texttt{luamcallbacks} for
%    more details.
%
%    \begin{macrocode}

function luatextra.default_reader(env, line)
    return line
end

function luatextra.default_close(env)
    return
end

function luatextra.default_pre_read(env)
    return env
end

%    \end{macrocode}
%
%    \subsection{Multiple callbacks on the \texttt{define\_font}
%    callback\label{sub:df}}
%
%    The same principle is applied to the \texttt{define\_font} callback. The
%    main difference is that this mechanism is not applied by default. The
%    reason is that the callback most people will register in the
%    \texttt{define\_font} callback is the one from Con\TeX t allowing the use
%    of OT fonts. When the code will be more adapted (not so soon certainly),
%    this mechanism will certainly be used, as it allows more flexibility in
%    the font syntax, the OT font load mechanism, etc.
%
%    The callbacks we register here are the following ones:
%
%    \begin{itemize}
%    \item \texttt{font\_syntax} that takes a table with the fields
%    \texttt{asked\_name}, \texttt{name} and \texttt{size}, and modifies this
%    table to add more information. It must add at least a \texttt{path}
%    field. The structure of the final table is not precisely defined, as it
%    can vary from one syntax to another.
%    \item \texttt{open\_otf\_font} takes the previous table, and must return
%    a valid font structure as described in the Lua\TeX\ manual.
%    \item \texttt{post\_font\_opening} takes the final font table and can
%    modify it, before this table is returned to the \texttt{define\_font}
%    callback.
%    \end{itemize}
%
%    But first, we acknowledge the fact that \texttt{fontforge} has been
%    renamed to \texttt{fontloader}. This check allows older versions of
%    Lua\TeX\ to use \texttt{fontloader}.
%
%    As this mechanism is not loaded by default and certainly won't be until
%    version 1.0 of Lua\TeX , we don't document it further. See the
%    documentation of \texttt{luatextra.sty} (macro
%    \texttt{\string\ltxtra\string@RegisterFontCallback}) to know how to load
%    this mechanism anyway.
%
%    \begin{macrocode}

do
  if tex.luatexversion < 36 then
      fontloader = fontforge
  end
end

function luatextra.find_font(name)
    local types = {'ofm', 'ovf', 'opentype fonts', 'truetype fonts'}
    local path = kpse.find_file(name)
    if path then return path end
    for _,t in pairs(types) do
        path = kpse.find_file(name, t)
        if path then return path end
    end
    return nil
end

function luatextra.font_load_error(error)
    luatextra.module_warning('luatextra', string.format('%s\nloading lmr10 instead...', error))
end

function luatextra.load_default_font(size)
    return font.read_tfm("lmr10", size)
end

function luatextra.define_font(name, size)
    if (size < 0) then size = (- 655.36) * size end
    local fontinfos = {
        asked_name = name,
        name = name,
        size = size
        }
    callback.call('font_syntax', fontinfos)
    name = fontinfos.name
    local path = fontinfos.path
    if not path then
        path = luatextra.find_font(name)
        fontinfos.path = luatextra.find_font(name)
    end
    if not path then
        luatextra.font_load_error("unable to find font "..name)
        return luatextra.load_default_font(size)
    end
    if not fontinfos.filename then
        fontinfos.filename = fpath.basename(path)
    end
    local ext = fpath.suffix(path)
    local f
    if ext == 'tfm' or ext == 'ofm' then
        f =  font.read_tfm(name, size)
    elseif ext == 'vf' or ext == 'ovf' then
        f =  font.read_vf(name, size)
    elseif ext == 'ttf' or ext == 'otf' or ext == 'ttc' then
        f = callback.call('open_otf_font', fontinfos)
    else
        luatextra.font_load_error("unable to determine the type of font "..name)
        f = luatextra.load_default_font(size)
    end
    if not f then
        luatextra.font_load_error("unable to load font "..name)
        f = luatextra.load_default_font(size)
    end
    callback.call('post_font_opening', f, fontinfos)
    return f
end

function luatextra.default_font_syntax(fontinfos)
    return
end

function luatextra.default_open_otf(fontinfos)
    return nil
end

function luatextra.default_post_font(f, fontinfos)
    return true
end

function luatextra.register_font_callback()
    callback.add('define_font', luatextra.define_font, 'luatextra.define_font')
end

do
    luatextra.use_module('luamcallbacks')
    callback.create('pre_read_file', 'simple', luatextra.default_pre_read)
    callback.create('file_reader', 'data', luatextra.default_reader)
    callback.create('file_close', 'simple', luatextra.default_close)
    callback.add('open_read_file', luatextra.open_read_file, 'luatextra.open_read_file')
    callback.create('font_syntax', 'simple', luatextra.default_font_syntax)
    callback.create('open_otf_font', 'first', luatextra.default_open_otf)
    callback.create('post_font_opening', 'simple', luatextra.default_post_font)

    if luatextrapath then
        texio.write(')')
    end
end
%    \end{macrocode}
% \iffalse
%</lua>
% \fi
%
% \section{\texttt{luatextra.sty}}
%
% \iffalse
%<*package>
% \fi
%
%    \subsection{Initializations}
%
%    First we prevent multiple loads of the file (useful for plain-\TeX ).
%
%    \begin{macrocode}
\csname ifluatextraloaded\endcsname
\let\ifluatextraloaded\endinput

%    \end{macrocode}
%
%    Then we load \textsf{ifluatex} and etex if under \LaTeX.
%
%    \begin{macrocode}

\expandafter\ifx\csname ProvidesPackage\endcsname\relax
  \expandafter\ifx\csname ifluatex\endcsname\relax
    \input ifluatex.sty
  \fi
\else
  \RequirePackage{ifluatex}
  \NeedsTeXFormat{LaTeX2e}
  \ProvidesPackage{luatextra}
    [2009/12/04 v0.95 LuaTeX extra low-level macros]
  \RequirePackage{etex}[1998/03/26]
\fi

%    \end{macrocode}
%
%    The two macros \texttt{\string\LuaTeX} and \texttt{\string\LuaLaTeX} are
%    defined to Lua\TeX\ and Lua\LaTeX , because that's the way it's written
%    in the Lua\TeX 's manual (not in small capitals).
%
%    These two macros are the only two loaded if we are under a non-Lua\TeX{}
%    engine.
%
%    \begin{macrocode}

\def\LuaTeX{Lua\TeX }
\def\LuaLaTeX{Lua\LaTeX }

%    \end{macrocode}
%
%    Here we end the loading of the file if we are under a non-Lua\TeX{}
%    engine, and we issue a warning.
%
%    \begin{macrocode}

\ifluatex\else
  \expandafter\ifx\csname ProvidesPackage\endcsname\relax
    \immediate\write16{}
    \immediate\write16{Package luatextra Warning: this package should be used with LuaTeX.}
  \else
    \PackageWarning{luatextra}{this package should be used with LuaTeX.}
  \fi
  \expandafter\endinput
\fi

\expandafter\ifx\csname ProvidesPackage\endcsname\relax
%    \end{macrocode}
%
%    If the package is loaded with Plain, we define
%    \texttt{\string\luaRequireModule} with two mandatory arguments.
%
%    \begin{macrocode}
  \def\luatexRequireModule#1#2{\luadirect{luatextra.require_module([[#1]], [[#2]])}}
\else
%    \end{macrocode}
%
%    If the package is loaded with \LaTeX , we define 
%    \texttt{\string\luaRequireModule} with one mandatory
%    argument (the name of the package) and one optional (the version or the
%    date). We also define the environment \texttt{luacode}.
%
%    \begin{macrocode}
  \RequirePackage{environ}
  \NewEnviron{luacode}{\luadirect{\BODY}}
  \newcommand\luatexRequireModule[2][0]{\luadirect{luatextra.require_module([[#2]], [[#1]])}}
%    \end{macrocode}
%
%    The \texttt{\string\input} is a hack that modifies some values in the
%    register attribution scheme of $\varepsilon$-\TeX\ and remaps
%    \texttt{\string\newcount} to \textsf{etex}'s \texttt{\string\globcount}.
%    We have to do such a remapping in a separate file that Plain doesn't see,
%    otherwise it outputs an error if we try to change
%    \texttt{\string\newcount} (because it is an \texttt{\string\outer}
%    macro). See section \ref{sub:latex} for the file content.
%
%    \begin{macrocode}
  \input luatextra-latex.tex
\fi

%    \end{macrocode}
%
% \subsection{Primitives renaming}
%
%    Here we differenciate two very different cases: Lua\TeX\ version < 0.36
%    has no \texttt{tex.enableprimitives} function, and has support for
%    multiple lua states, and for versions > 0.35, the
%    \texttt{tex.enableprimitives} is provided, and the old
%    \texttt{\string\directlua} syntax prints a warning.
%
%    \begin{macrocode}

\ifnum\luatexversion<36
%    \end{macrocode}
%
%    For old versions, we simply rename the primitives. You can note that
%    \texttt{\string\attribute} (and also others) have no
%    \texttt{\string\primitive} before them, because it would make users
%    unable to call \texttt{\string\global\string\luaattribute}, which is a
%    strong restriction. With this method, we can call it, but if
%    \texttt{\string\attribute} was defined before, this means that
%    \texttt{\string\luaattribute} will get its meaning, which is dangerous.
%    Note also that you cannot use multiple states.
%
%    \begin{macrocode}
  \def\directlua{\pdfprimitive\directlua0}
  \def\latelua{\pdfprimitive\latelua0}
  \def\luadirect{\pdfprimitive\directlua0}
  \def\lualate{\pdfprimitive\latelua0}
  \def\luatexattribute{\attribute}
  \def\luatexattributedef{\attributedef}
  \def\luatexclearmarks{\pdfprimitive\luaclearmarks}
  \def\luatexformatname{\pdfprimitive\formatname}
  \def\luatexscantexttokens{\pdfprimitive\scantexttokens}
  \def\luatexcatcodetable{\catcodetable}
  \def\initluatexcatcodetable{\pdfprimitive\initcatcodetable}
  \def\saveluatexcatcodetable{\pdfprimitive\savecatcodetable}
  \def\luaclose{\pdfprimitive\closelua}
\else
%    \end{macrocode}
%
%    From TeXLive 2009, all primitives should be provided with the |luatex|
%    prefix. For TeXLive 2008, we provide some primitives with this prefix too,
%    to keep backward compatibility.
%
%    \begin{macrocode}
  \directlua{tex.enableprimitives('luatex', {'attribute'})}
  \directlua{tex.enableprimitives('luatex', {'attributedef'})}
  \directlua{tex.enableprimitives('luatex', {'clearmarks'})}
  \directlua{tex.enableprimitives('luatex', {'formatname'})}
  \directlua{tex.enableprimitives('luatex', {'scantexttokens'})}
  \directlua{tex.enableprimitives('luatex', {'catcodetable'})}
  \directlua{tex.enableprimitives('luatex', {'latelua'})}
  \directlua{tex.enableprimitives('luatex', {'initcatcodetable'})}
  \directlua{tex.enableprimitives('luatex', {'savecatcodetable'})}
  \directlua{tex.enableprimitives('luatex', {'closelua'})}
  \let\luadirect\directlua
  \let\lualate\luatexlatelua
  \let\initluatexcatcodetable\luatexinitcatcodetable
  \let\saveluatexcatcodetable\luatexsavecatcodetable
  \let\luaclose\luatexcloselua
\fi


%    \end{macrocode}
%
%    We load the \texttt{lua} file.
%
%    \begin{macrocode}

\luadirect{dofile(kpse.find_file("luatextra.lua"))}

%    \end{macrocode}
%
%    A small macro to register the \texttt{define\_font} callback from
%    \textsf{luatextra}. See section \ref{sub:df} for more details.
%
%    \begin{macrocode}

\def\ltxtra@RegisterFontCallback{
  \luadirect{luatextra.register_font_callback()}
}

%    \end{macrocode}
%
%    \subsection{Module handling}
%
%    The \texttt{\string\luaModuleError} macro is called by the lua function
%    \texttt{luatextra.module\_error}. It is necessary because we can't call
%    directly \texttt{\string\errmessage} in lua.
%
%    \subsection{Module handling}
%
%    The \texttt{\string\luatexModuleError} macro is called by the lua function
%    \texttt{luatextra.module\_error}. It is necessary because we can't call
%    directly \texttt{\string\errmessage} in lua. Then we define
%    \texttt{\string\luatexUseModule} that simply calls
%    \texttt{luatextra.use\_module}. Remember that
%    \texttt{\string\luatexRequireModule} is defined at the beginning of this
%    file.
%
%    \begin{macrocode}

\def\luatexModuleError#1#2{%
  \errorcontextlines=0\relax
  \immediate\write16{}%
  \errmessage{Module #1 error: #2^^J^^J%
See the module #1 documentation for explanation.^^J ...^^J}%
}

\def\luatexUseModule#1{\luadirect{luatextra.use_module([[#1]])}}

%    \end{macrocode}
%
%    \subsection{Attributes handling}
%
%    The most important macro here is \texttt{\string\newluatexattribute} that
%    allocates a new attribute, and adds it in the \texttt{tex.attributename}
%    table (see \texttt{luatextra.attributedef\_from\_tex} for more details.
%    It works just like the other \texttt{\string\new*} macros, we can
%    allocate up to 65536 different attributes.
%
%    \begin{macrocode}


\newcount\luatexattdefcounter
\luatexattdefcounter = 1

\def\newluatexattribute#1{%
  \ifnum\luatexattdefcounter<65535\relax %
    \global\advance\luatexattdefcounter by 1\relax %
    \allocationnumber\luatexattdefcounter %
    \ifluatex %
      \global\luatexattributedef#1=\allocationnumber %
    \fi %
    \wlog{\string#1=\string\luatexattribute\the\allocationnumber}%
    \luadirect{%
      luatextra.attributedef_from_tex([[\noexpand#1]], '\number\allocationnumber')}%
  \else %
    \errmessage{No room for a new \string\attribute}%
  \fi %
}

%    \end{macrocode}
%
%    Two convenient macros, one to set an attribute (basically just a
%    wrapper), and another one to uset it. Unsetting attributes with this
%    function is important, as the \texttt{unset} value may change, as it
%    already has in the 0.37 version.
%
%    \begin{macrocode}

\def\setluatexattribute#1#2{%
  #1=\numexpr#2\relax %
}

\def\unsetluatexattribute#1{%
  \ifnum\luatexversion<37\relax %
    #1=-1\relax %
  \else %
    #1=-"7FFFFFFF\relax %
  \fi %
}

%    \end{macrocode}
%
%    \subsection{Catcodetables handling}
%
%    Here we allocate catcodetables the same way we handle attributes.
%
%    \begin{macrocode}

\newcount\luatexcatcodetabledefcounter

\luatexcatcodetabledefcounter = 1

\def\newluatexcatcodetable#1{%
  \ifnum\luatexcatcodetabledefcounter<1114110\relax % 0x10FFFF is maximal \chardef
    \global\advance\luatexcatcodetabledefcounter by 1\relax %
    \allocationnumber=\luatexcatcodetabledefcounter %
    \global\chardef#1=\allocationnumber %
    \luadirect{%
      luatextra.catcodetabledef_from_tex([[\noexpand#1]], '\number\allocationnumber')}%
    \wlog{\string#1=\string\catcodetable\the\allocationnumber}%
  \else %
    \errmessage{No room for a new \string\catcodetable}%
  \fi %
}

%    \end{macrocode}
%
%    A small patch to manage the catcode of \@ in Plain, and to get two new
%    counters in Plain too.
%
%    \begin{macrocode}

\expandafter\edef\csname ltxtra@AtEnd\endcsname{%
  \catcode64 \the\catcode64\relax
}

\catcode 64=11\relax

\expandafter\ifx\csname @tempcnta\endcsname\relax
  \csname newcount\endcsname\@tempcnta
\fi
\expandafter\ifx\csname @tempcntb\endcsname\relax
  \csname newcount\endcsname\@tempcntb
\fi

%    \end{macrocode}
%
%    A macro that sets the catcode of a range of characters. The first
%    parameter is the character number of the first character of the range,
%    the second parameter is one for the last character, and the third
%    parameter is the catcode we want them to have.
%
%    \begin{macrocode}

\def\luatexsetcatcoderange#1#2#3{%
  \edef\luaSCR@temp{%
    \noexpand\@tempcnta=\the\@tempcnta
    \noexpand\@tempcntb=\the\@tempcntb
    \noexpand\count@=\the\count@
    \relax
  }%
  \@tempcnta=#1\relax
  \@tempcntb=#2\relax
  \count@=#3\relax
  \loop\unless\ifnum\@tempcnta>\@tempcntb
    \catcode\@tempcnta=\count@
    \advance\@tempcnta by 1\relax
  \repeat
  \luaSCR@temp
}

%    \end{macrocode}
%
%    Finally we create several catcodetables that may be used by the user.
%    These are:
%
%    \begin{itemize}
%    \item \texttt{\string\CatcodeTableIniTeX}: the base \TeX\ catcodes
%    \item \texttt{\string\CatcodeTableString}: almost all characters have
%    catcode 12
%    \item \texttt{\string\CatcodeTableOther}: all characters have catcode 12
%    (even space)
%    \item \texttt{\string\CatcodeTableLaTeX}: the \LaTeX\ classical catcodes
%    \item \texttt{\string\CatcodeTableLaTeXAtLetter}: the \LaTeX\ classical
%    catcodes and |@| letter
%    \item \texttt{\string\CatcodeTableExpl}: the expl3 catcodes
%    \end{itemize}
%
%    \begin{macrocode}

\newluatexcatcodetable\CatcodeTableIniTeX
\newluatexcatcodetable\CatcodeTableString
\newluatexcatcodetable\CatcodeTableOther
\newluatexcatcodetable\CatcodeTableLaTeX
\newluatexcatcodetable\CatcodeTableLaTeXAtLetter
\newluatexcatcodetable\CatcodeTableExpl
\initluatexcatcodetable\CatcodeTableIniTeX

\expandafter\ifx\csname @firstofone\endcsname\relax
  \long\def\@firstofone#1{#1}%
\fi

\begingroup
  \def\@makeother#1{\catcode#1=12\relax}%
  \@firstofone{%
    \luatexcatcodetable\CatcodeTableIniTeX
    \begingroup
      \luatexsetcatcoderange{0}{8}{15}%
      \catcode9=10  % tab
      \catcode11=15 %
      \catcode12=13 % form feed
      \luatexsetcatcoderange{14}{31}{15}%
      \catcode35=6 % hash
      \catcode36=3 % dollar
      \catcode38=4 % ampersand
      \catcode94=7 % circumflex
      \catcode95=8 % underscore
      \catcode123=1 % brace left
      \catcode125=2 % brace right
      \catcode126=13 % tilde
      \catcode127=15 %
      \saveluatexcatcodetable\CatcodeTableLaTeX
      \catcode64=11 %
      \saveluatexcatcodetable\CatcodeTableLaTeXAtLetter
    \endgroup
    \begingroup
      \luatexsetcatcoderange{0}{8}{15}%
      \catcode9=9 % tab ignored
      \catcode11=15 %
      \catcode12=13 % form feed
      \luatexsetcatcoderange{14}{31}{15}%
      \catcode32=9 % space is ignored
      \catcode35=6 % hash mark is macro parameter character
      \catcode36=3 % dollar (not so sure about the catcode...)
      \catcode38=4 % ampersand
      \catcode58=11 % colon letter
      \catcode94=7 % circumflex is superscript character
      \catcode95=11 % underscore letter
      \catcode123=1 % left brace is begin-group character
      \catcode125=2 % right brace is end-group character
      \catcode126=10 % tilde is a space char.
      \catcode127=15 %
      \saveluatexcatcodetable\CatcodeTableExpl
    \endgroup
    \@makeother{0}% nul
    \@makeother{13}% carriage return
    \@makeother{37}% percent
    \@makeother{92}% backslash
    \@makeother{127}%
    \luatexsetcatcoderange{65}{90}{12}% A-Z
    \luatexsetcatcoderange{97}{122}{12}% a-z
    \saveluatexcatcodetable\CatcodeTableString
    \@makeother{32}% space
    \saveluatexcatcodetable\CatcodeTableOther
  \endgroup
}

\ltxtra@AtEnd

\luadirect{luatextra.catcodetable_do_shortcuts()}

%    \end{macrocode}
%
%    We provide some functions for backward compatibility with old versions of luatextra.
%
%    \begin{macrocode}

\let\newluaattribute\newluatexattribute
\let\luaattribute\luatexattribute
\let\unsetluaattribute\unsetluatexattribute
\let\initluacatcodetable\initluatexcatcodetable
\let\luasetcatcoderange\luatexsetcatcoderange
\let\newluacatcodetable\newluatexcatcodetable
\let\setluaattribute\setluatexattribute
\let\luaModuleError\luatexModuleError
\let\luaRequireModule\luatexRequireModule
\let\luaUseModule\luatexUseModule

%    \end{macrocode}
%
%    Finally, we load \textsf{luaotfload}.
%
%    \begin{macrocode}

\expandafter\ifx\csname ProvidesPackage\endcsname\relax
  \input luaotfload.sty
\else
  \RequirePackage{luaotfload}
\fi

%    \end{macrocode}
% \iffalse
%</package>
% \fi
%
% \section{\texttt{luatextra-latex.tex}\label{sub:latex}}
%
% \iffalse
%<*latex>
% \fi
%
%    This file is very small, it just changes the maximum values of allowed
%    registers from 32768 to 65536, and remaps \texttt{\string\newcount} (and
%    friends) to \textsf{etex}'s \texttt{\string\globcount}.
%
%    \begin{macrocode}
\def\ltxtra@temp#1{%
\ifnum\count27#1=32768 %
  \count27#1=65536 %
\fi
}%
\ltxtra@temp0%
\ltxtra@temp1%
\ltxtra@temp2%
\ltxtra@temp3%
\ltxtra@temp4%
\ltxtra@temp5%
\ltxtra@temp6%
\let\newcount\globcount
\let\newdimen\globdimen
\let\newskip\globskip
\let\newbox\globbox
%    \end{macrocode}
% \iffalse
%</latex>
% \fi
%
%
% \Finale
\endinput
