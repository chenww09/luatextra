% \iffalse meta-comment
%
% Copyright (C) 2009 by Elie Roux <elie.roux@telecom-bretagne.eu>
%
% This work is under the CC0 license.
%
% This work consists of the main source file luatextra.dtx
% and the derived files
%    luatextra.sty, luatextra.lua, luatextra-latex.tex, luatextra.pdf.
%
% Unpacking:
%    tex luatextra.dtx
%
% Documentation:
%    pdflatex luatextra.dtx
%
%    The class ltxdoc loads the configuration file ltxdoc.cfg
%    if available. Here you can specify further options, e.g.
%    use A4 as paper format:
%       \PassOptionsToClass{a4paper}{article}
%
%
%
%<*ignore>
\begingroup
  \def\x{LaTeX2e}%
\expandafter\endgroup
\ifcase 0\ifx\install y1\fi\expandafter
         \ifx\csname processbatchFile\endcsname\relax\else1\fi
         \ifx\fmtname\x\else 1\fi\relax
\else\csname fi\endcsname
%</ignore>
%<*install>
\input docstrip.tex
\Msg{************************************************************************}
\Msg{* Installation}
\Msg{* Package: luatextra 2009/12/16 v0.95 Extra low level functions for LuaTeX}
\Msg{************************************************************************}

\keepsilent
\askforoverwritefalse

\let\MetaPrefix\relax

\preamble
This is a generated file.

Copyright (C) 2009 by Elie Roux <elie.roux@telecom-bretagne.eu>

This work is under the CC0 license.

This work consists of the main source file luainputenc.dtx
and the derived files
    luatextra.sty, luatextra.lua, luatextra-latex.tex, luatextra.pdf

\endpreamble

\let\MetaPrefix\DoubleperCent


\generate{%
  \usedir{tex/luatex/luatextra}%
  \file{luatextra.sty}{\from{luatextra.dtx}{package}}%
  \file{luatextra-latex.tex}{\from{luatextra.dtx}{latex}}%
}

% The following hacks are to generate a lua file with lua comments starting by
% -- instead of %%

\def\MetaPrefix{-- }

\def\luapostamble{%
  \MetaPrefix^^J%
  \MetaPrefix\space End of File `\outFileName'.%
}

\def\currentpostamble{\luapostamble}%

\generate{%
  \usedir{tex/luatex/luatextra}%
  \file{luatextra.lua}{\from{luatextra.dtx}{lua}}%%
}

\obeyspaces
\Msg{************************************************************************}
\Msg{*}
\Msg{* To finish the installation you have to move the following}
\Msg{* files into a directory searched by TeX:}
\Msg{*}
\Msg{*     luatextra.sty luatextra-latex.tex luatextra.lua}
\Msg{*}
\Msg{* Happy TeXing!}
\Msg{*}
\Msg{************************************************************************}

\endbatchfile
%</install>
%<*ignore>
\fi
%</ignore>
%<*driver>
\NeedsTeXFormat{LaTeX2e}
\ProvidesFile{luaminimalotf.drv}%
  [2009/12/16 v0.95 LuaTeX extra low-level macros.]%
\documentclass{ltxdoc}
\EnableCrossrefs
\CodelineIndex
\begin{document}
  \DocInput{luatextra.dtx}%
\end{document}
%</driver>
% \fi
%
% \CheckSum{0}
%
% \CharacterTable
%  {Upper-case    \A\B\C\D\E\F\G\H\I\J\K\L\M\N\O\P\Q\R\S\T\U\V\W\X\Y\Z
%   Lower-case    \a\b\c\d\e\f\g\h\i\j\k\l\m\n\o\p\q\r\s\t\u\v\w\x\y\z
%   Digits        \0\1\2\3\4\5\6\7\8\9
%   Exclamation   \!     Double quote  \"     Hash (number) \#
%   Dollar        \$     Percent       \%     Ampersand     \&
%   Acute accent  \'     Left paren    \(     Right paren   \)
%   Asterisk      \*     Plus          \+     Comma         \,
%   Minus         \-     Point         \.     Solidus       \/
%   Colon         \:     Semicolon     \;     Less than     \<
%   Equals        \=     Greater than  \>     Question mark \?
%   Commercial at \@     Left bracket  \[     Backslash     \\
%   Right bracket \]     Circumflex    \^     Underscore    \_
%   Grave accent  \`     Left brace    \{     Vertical bar  \|
%   Right brace   \}     Tilde         \~}
%
% \GetFileInfo{luatextra.drv}
%
% \title{The \textsf{luatextra} package}
% \date{2009/12/16 v0.95}
% \author{Elie Roux \\ \texttt{elie.roux@telecom-bretagne.eu}}
%
% \maketitle
%
% \begin{abstract}
% \textsf{luatextra} provides low-level addition to the formats Plain and
% \LaTeX\ to be used with the engine Lua\TeX.
% \end{abstract}
%
% \tableofcontents
%
% \section{Documentation}
%
% \subsection{Preamble}
%
% This document is made for people wanting to understand how the package was
% made. For an introduction to the use of Lua\TeX\ with the formats Plain and
% \LaTeX , please read the document \texttt{luatextra-reference.pdf} that you
% can find in your \TeX\ distribution (\TeX Live from version 2009) or on the
% CTAN.
%
% \subsection{History of formats and engines}
%
% To understand this package, one must fist understand some historical choices
% in the \TeX\ world.
%
% A \TeX\ engine is a binary executable that provides some very low-level
% primitives, for example \texttt{\string\count} to set a counter to a certain
% value. A \TeX\ format is a macro package that provides higher-level macros
% for the user and the package developer, for example
% \texttt{\string\newcount} that allocates a new counter and gives it a name.
% Examples of engines are the old \TeX\ 82, $\varepsilon$-\TeX, pdf\TeX,
% Omega/Aleph, Lua\TeX\ and Xe\TeX. Examples of formats are Plain, \LaTeX\ and
% Con\TeX t.
%
% This distinction is hard to make as only one command is invoked, for example
% when you call the command \texttt{tex}, you often have no idea that the
% engine \TeX\ 82 is invoked with the format Plain.
%
% Evolution is also something confusing in the \TeX\ world: engines often
% evolve, and new engines have always appeared, when most formats are frozen:
% the Plain and \LaTeX\ formats do not accept any new code to cope with the
% new engines. In theory, this package shouldn't exist, or at least shouldn't
% be a package, but its code should be integrated into a format. But as Plain
% and \LaTeX\ are frozen, people wanting to take advantage of the new engines
% have to use a package.
%
% This package is really necessary to take advantage of Lua\TeX\ as it
% provides things users are expecting a macro package to provide, for example
% \texttt{\string\newluaattribute} that acts like \texttt{\string\newcount}
% for lua attributes. It also enables all Lua\TeX\ primitives, that are
% disabled by default.
%
% \subsection{choices made in this package}
%
% In the very long term, it is higly possible that Lua\TeX\ will replace
% pdf\TeX\ as the default \LaTeX\ engine, so it is necessary to keep backward
% compatibility. This lead us to the decision of renaming Lua\TeX -only
% primitives so that they all start by \texttt{luatex}, like the pdf\TeX -only
% primitives start by \texttt{pdf}. Thus attributes become luatexattributes,
% etc. This % also allows primitives to keep having the same name, even if their
% name is changed later at the engine level. Also some new functions like
% \texttt{newluatexattribute} are provided with the \texttt{lua} prefix, to
% shorten the already too long name.
%
% \subsection{registers allocation scheme}
%
% The default register allocation scheme of \LaTeX\ is old and limited (like
% the one of \TeX 82) to 256 values. The engine $\varepsilon$-\TeX allows more
% different registers (up to 32768), and Lua\TeX\ allows even 65536 ones.
% These new limits were not acknowledged by \LaTeX . A package \textsf{etex}
% was created for \LaTeX\ to extends the allocation scheme. \textsf{luatextra}
% loads \textsf{etex}, and overrides somes values to extend the allocation max
% number to 65536.
%
% \subsection{attributes}
%
% Attributes are a new concept in Lua\TeX\ (see the Lua\TeX\ documentation for
% details). As the macro \texttt{\string\attribute} is certainly very common
% in the user's documents, they are renamed \texttt{luaattribute}s. This
% package provides a simple way to allocate new attributes, with the macro
% \texttt{\string\newluaattribute}. For more informations about attribute
% handling in lua, please read section \ref{sub:attr}.
%
% \subsection{Multiple callbacks handling}
%
% Lua\TeX\ has no way to register multiple functions in a callback. This
% package loads \textsf{luamcallbacks} that provides a safe way to do so. But
% the \textsf{luamcallbacks} package can't register several functions in some
% callbacks, like \texttt{open\_read\_file} and \texttt{define\_font}. This
% package takes advantage of the callback creation possibilities of
% \textsf{luamcallbacks} to split these callbacks into several ones that can
% agregate several functions. Thus it allows several packages to safely use
% the callbacks. See section \ref{sub:orf} for more details.
%
% \section{\texttt{luatextra.lua}}
%
% \subsection{Initialization and internal functions}
%
% \iffalse
%<*lua>
% \fi
%
%    \TeX\ always prints the names of the files that are input. Unfortunatly
%    it can't do so with lua files called with \texttt{dofile}. We will fix it
%    with the \texttt{luatextra.use\_module} function, but in the meantime we
%    print this information for the \texttt{luatextra.lua} file.
%
%    A change compared to usual filename printings is the fact that Lua\TeX\
%    does not print the \texttt{./} for files in the current directory. We
%    keep this convention for lua filename printings.
%
%    \begin{macrocode}
do
    local luatextrapath = kpse.find_file("luatextra.lua")
    if luatextrapath then
        if luatextrapath:sub(1,2) == "./" then
            luatextrapath = luatextrapath:sub(3)
        end
        texio.write_nl('('..luatextrapath)
    end
end

%    \end{macrocode}
%
%    We create the \texttt{luatextra} table that will contain all the
%    functions and variables, and we register it as a normal lua module.
%
%    \begin{macrocode}

luatextra = {}

module("luatextra", package.seeall)

%    \end{macrocode}
%
%    We initiate the modules table that will contain informations about the
%    loaded modules. And we register the \texttt{luatextra} module. The
%    informations contained in the table describing the module are always the
%    same, it can be taken as a template. See
%    \texttt{luatextra.provides\_module} for more details.
%
%    \begin{macrocode}

luatextra.modules = {}

luatextra.modules['luatextra'] = {
    version     = 0.95,
    name        = "luatextra",
    date        = "2009/12/16",
    description = "Additional low level functions for LuaTeX",
    author      = "Elie Roux",
    copyright   = "Elie Roux, 2009",
    license     = "CC0",
}

local format = string.format

%    \end{macrocode}
%
%    \subsection{Multiple callbacks on the \texttt{open\_read\_file}
%    callback\label{sub:orf}}
%
%    The luamcallbacks (see documentation for details) cannot really provide a
%    simple and reliable way of registering multiple functions in some
%    callbacks. To be able to do so, the solution we implemented is to
%    register one function in these callbacks, and to create "sub-callbacks"
%    that can accept several functions. That's what we do here for the
%    callback \texttt{open\_read\_file}.
%
%    \begin{macro}{luatextra.open read file}
%
%    This function is the one that will be registered in the callback. It
%    calls new callbacks, that will be created later. These callbacks are:
%
%    \begin{itemize}
%    \item \texttt{pre\_read\_file} in which you can register a function with
%    the signature \texttt{pre\_read\_file(env)}, with \texttt{env} being a
%    table containing the fields \texttt{filename} which is the argument of
%    the callback \texttt{open\_read\_file}, and \texttt{path} which is the
%    result of \texttt{kpse.find\_file}. You can put any field you want in the
%    \texttt{env} table, you can even override the existing fields. This
%    function is called at the very beginning of the callback, it allows for
%    instance to register functions in the other callbacks. It is useless to
%    add a field \texttt{reader} or \texttt{close}, as they will be overriden.
%    \item \texttt{file\_reader} is automatically registered in the
%    \texttt{reader} callback for every file, it has the same signature.
%    \item \texttt{file\_close} is registered in the \texttt{close} callback
%    for every file, and has the same signature.
%    \end{itemize}
%
%    \begin{macrocode}

function luatextra.open_read_file(filename)
    local path = kpse.find_file(filename)
    local env = {
      ['filename'] = filename,
      ['path'] = path,
    }
    luamcallbacks.call('pre_read_file', env)
    path = env.path
    if not path then
        return
    end
    local f = env.file
    if not f then
        f = io.open(path)
        env.file = f
    end
    if not f then
        return
    end
    env.reader = luatextra.reader
    env.close = luatextra.close
    return env
end

%    \end{macrocode}
%
% \end{macro}
%
%    The two next functions are the one called in the
%    \texttt{open\_read\_file} callback.
%
%    \begin{macrocode}

function luatextra.reader(env)
    local line = (env.file):read()
    line = luamcallbacks.call('file_reader', env, line)
    return line
end

function luatextra.close(env)
    (env.file):close()
    luamcallbacks.call('file_close', env)
end

%    \end{macrocode}
%
%    In the callback creation process we need to have default behaviours. Here
%    they are. These are called only when no function is registered in the
%    created callback. See the documentation of \texttt{luamcallbacks} for
%    more details.
%
%    \begin{macrocode}

function luatextra.default_reader(env, line)
    return line
end

function luatextra.default_close(env)
    return
end

function luatextra.default_pre_read(env)
    return env
end

%    \end{macrocode}
%
%    \subsection{Multiple callbacks on the \texttt{define\_font}
%    callback\label{sub:df}}
%
%    The same principle is applied to the \texttt{define\_font} callback. The
%    main difference is that this mechanism is not applied by default. The
%    reason is that the callback most people will register in the
%    \texttt{define\_font} callback is the one from Con\TeX t allowing the use
%    of OT fonts. When the code will be more adapted (not so soon certainly),
%    this mechanism will certainly be used, as it allows more flexibility in
%    the font syntax, the OT font load mechanism, etc.
%
%    The callbacks we register here are the following ones:
%
%    \begin{itemize}
%    \item \texttt{font\_syntax} that takes a table with the fields
%    \texttt{asked\_name}, \texttt{name} and \texttt{size}, and modifies this
%    table to add more information. It must add at least a \texttt{path}
%    field. The structure of the final table is not precisely defined, as it
%    can vary from one syntax to another.
%    \item \texttt{open\_otf\_font} takes the previous table, and must return
%    a valid font structure as described in the Lua\TeX\ manual.
%    \item \texttt{post\_font\_opening} takes the final font table and can
%    modify it, before this table is returned to the \texttt{define\_font}
%    callback.
%    \end{itemize}
%
%    But first, we acknowledge the fact that \texttt{fontforge} has been
%    renamed to \texttt{fontloader}. This check allows older versions of
%    Lua\TeX\ to use \texttt{fontloader}.
%
%    As this mechanism is not loaded by default and certainly won't be until
%    version 1.0 of Lua\TeX , we don't document it further. See the
%    documentation of \texttt{luatextra.sty} (macro
%    \texttt{\string\ltxtra\string@RegisterFontCallback}) to know how to load
%    this mechanism anyway.
%
%    \begin{macrocode}

do
  if tex.luatexversion < 36 then
      fontloader = fontforge
  end
end

function luatextra.find_font(name)
    local types = {'ofm', 'ovf', 'opentype fonts', 'truetype fonts'}
    local path = kpse.find_file(name)
    if path then return path end
    for _,t in pairs(types) do
        path = kpse.find_file(name, t)
        if path then return path end
    end
    return nil
end

function luatextra.font_load_error(error)
    luatextra.module_warning('luatextra', string.format('%s\nloading lmr10 instead...', error))
end

function luatextra.load_default_font(size)
    return font.read_tfm("lmr10", size)
end

function luatextra.define_font(name, size)
    if (size < 0) then size = (- 655.36) * size end
    local fontinfos = {
        asked_name = name,
        name = name,
        size = size
        }
    callback.call('font_syntax', fontinfos)
    name = fontinfos.name
    local path = fontinfos.path
    if not path then
        path = luatextra.find_font(name)
        fontinfos.path = luatextra.find_font(name)
    end
    if not path then
        luatextra.font_load_error("unable to find font "..name)
        return luatextra.load_default_font(size)
    end
    if not fontinfos.filename then
        fontinfos.filename = fpath.basename(path)
    end
    local ext = fpath.suffix(path)
    local f
    if ext == 'tfm' or ext == 'ofm' then
        f =  font.read_tfm(name, size)
    elseif ext == 'vf' or ext == 'ovf' then
        f =  font.read_vf(name, size)
    elseif ext == 'ttf' or ext == 'otf' or ext == 'ttc' then
        f = callback.call('open_otf_font', fontinfos)
    else
        luatextra.font_load_error("unable to determine the type of font "..name)
        f = luatextra.load_default_font(size)
    end
    if not f then
        luatextra.font_load_error("unable to load font "..name)
        f = luatextra.load_default_font(size)
    end
    callback.call('post_font_opening', f, fontinfos)
    return f
end

function luatextra.default_font_syntax(fontinfos)
    return
end

function luatextra.default_open_otf(fontinfos)
    return nil
end

function luatextra.default_post_font(f, fontinfos)
    return true
end

function luatextra.register_font_callback()
    callback.add('define_font', luatextra.define_font, 'luatextra.define_font')
end

do
    luatextra.use_module('luamcallbacks')
    callback.create('pre_read_file', 'simple', luatextra.default_pre_read)
    callback.create('file_reader', 'data', luatextra.default_reader)
    callback.create('file_close', 'simple', luatextra.default_close)
    callback.add('open_read_file', luatextra.open_read_file, 'luatextra.open_read_file')
    callback.create('font_syntax', 'simple', luatextra.default_font_syntax)
    callback.create('open_otf_font', 'first', luatextra.default_open_otf)
    callback.create('post_font_opening', 'simple', luatextra.default_post_font)

    if luatextrapath then
        texio.write(')')
    end
end
%    \end{macrocode}
% \iffalse
%</lua>
% \fi
%
% \section{\texttt{luatextra.sty}}
%
% \iffalse
%<*package>
% \fi
%
%    \subsection{Initializations}
%
%    First we prevent multiple loads of the file (useful for plain-\TeX ).
%
%    \begin{macrocode}
\csname ifluatextraloaded\endcsname
\let\ifluatextraloaded\endinput

%    \end{macrocode}
%
%    Then we load \textsf{ifluatex} and etex if under \LaTeX.
%
%    \begin{macrocode}

\expandafter\ifx\csname ProvidesPackage\endcsname\relax
  \expandafter\ifx\csname ifluatex\endcsname\relax
    \input ifluatex.sty
  \fi
\else
  \RequirePackage{ifluatex}
  \NeedsTeXFormat{LaTeX2e}
  \ProvidesPackage{luatextra}
    [2009/12/16 v0.95 LuaTeX extra low-level macros]
\fi

%    \end{macrocode}
%
%    The two macros \texttt{\string\LuaTeX} and \texttt{\string\LuaLaTeX} are
%    defined to Lua\TeX\ and Lua\LaTeX , because that's the way it's written
%    in the Lua\TeX 's manual (not in small capitals).
%
%    These two macros are the only two loaded if we are under a non-Lua\TeX{}
%    engine.
%
%    \begin{macrocode}

\def\LuaTeX{Lua\TeX }
\def\LuaLaTeX{Lua\LaTeX }

%    \end{macrocode}
%
%    Here we end the loading of the file if we are under a non-Lua\TeX{}
%    engine, and we issue a warning.
%
%    \begin{macrocode}

\ifluatex\else
  \expandafter\ifx\csname ProvidesPackage\endcsname\relax
    \immediate\write16{}
    \immediate\write16{Package luatextra Warning: this package should be used with LuaTeX.}
  \else
    \PackageWarning{luatextra}{this package should be used with LuaTeX.}
  \fi
  \expandafter\endinput
\fi

%    \end{macrocode}
%
%    If the package is loaded with \LaTeX , we
%    also define the environment \texttt{luacode}.
%
%    \begin{macrocode}
\expandafter\ifx\csname ProvidesPackage\endcsname\relax \else
  \RequirePackage{environ}
  \NewEnviron{luacode}{\luadirect{\BODY}}
\fi
%    \end{macrocode}
%
%
% \subsection{Primitives renaming}
%
%    Here we differenciate two very different cases: Lua\TeX\ version < 0.36
%    has no \texttt{tex.enableprimitives} function, and has support for
%    multiple lua states, and for versions > 0.35, the
%    \texttt{tex.enableprimitives} is provided, and the old
%    \texttt{\string\directlua} syntax prints a warning.
%
%    \begin{macrocode}

\ifnum\luatexversion<36
%    \end{macrocode}
%
%    For old versions, we simply rename the primitives. You can note that
%    \texttt{\string\attribute} (and also others) have no
%    \texttt{\string\primitive} before them, because it would make users
%    unable to call \texttt{\string\global\string\luaattribute}, which is a
%    strong restriction. With this method, we can call it, but if
%    \texttt{\string\attribute} was defined before, this means that
%    \texttt{\string\luaattribute} will get its meaning, which is dangerous.
%    Note also that you cannot use multiple states.
%
%    \begin{macrocode}
  \def\directlua{\pdfprimitive\directlua0}
  \def\latelua{\pdfprimitive\latelua0}
  \def\luadirect{\pdfprimitive\directlua0}
  \def\lualate{\pdfprimitive\latelua0}
  \def\luatexattribute{\attribute}
  \def\luatexattributedef{\attributedef}
  \def\luatexclearmarks{\pdfprimitive\luaclearmarks}
  \def\luatexformatname{\pdfprimitive\formatname}
  \def\luatexscantexttokens{\pdfprimitive\scantexttokens}
  \def\luatexcatcodetable{\catcodetable}
  \def\initluatexcatcodetable{\pdfprimitive\initcatcodetable}
  \def\saveluatexcatcodetable{\pdfprimitive\savecatcodetable}
  \def\luaclose{\pdfprimitive\closelua}
\else
%    \end{macrocode}
%
%    From TeXLive 2009, all primitives should be provided with the |luatex|
%    prefix. For TeXLive 2008, we provide some primitives with this prefix too,
%    to keep backward compatibility.
%
%    \begin{macrocode}
  \directlua{tex.enableprimitives('luatex', {'attribute'})}
  \directlua{tex.enableprimitives('luatex', {'attributedef'})}
  \directlua{tex.enableprimitives('luatex', {'clearmarks'})}
  \directlua{tex.enableprimitives('luatex', {'formatname'})}
  \directlua{tex.enableprimitives('luatex', {'scantexttokens'})}
  \directlua{tex.enableprimitives('luatex', {'catcodetable'})}
  \directlua{tex.enableprimitives('luatex', {'latelua'})}
  \directlua{tex.enableprimitives('luatex', {'initcatcodetable'})}
  \directlua{tex.enableprimitives('luatex', {'savecatcodetable'})}
  \directlua{tex.enableprimitives('luatex', {'closelua'})}
  \let\luadirect\directlua
  \let\lualate\luatexlatelua
  \let\initluatexcatcodetable\luatexinitcatcodetable
  \let\saveluatexcatcodetable\luatexsavecatcodetable
  \let\luaclose\luatexcloselua
\fi


%    \end{macrocode}
%
%    We load the \texttt{lua} file.
%
%    \begin{macrocode}

\luadirect{dofile(kpse.find_file("luatextra.lua"))}

%    \end{macrocode}
%
%    A small macro to register the \texttt{define\_font} callback from
%    \textsf{luatextra}. See section \ref{sub:df} for more details.
%
%    \begin{macrocode}

\def\ltxtra@RegisterFontCallback{
  \luadirect{luatextra.register_font_callback()}
}

%    \end{macrocode}
%
%    We provide some functions for backward compatibility with old versions of luatextra.
%
%    \begin{macrocode}

\let\newluaattribute\newluatexattribute
\let\luaattribute\luatexattribute
\let\unsetluaattribute\unsetluatexattribute
\let\initluacatcodetable\initluatexcatcodetable
\let\luasetcatcoderange\luatexsetcatcoderange
\let\newluacatcodetable\newluatexcatcodetable
\let\setluaattribute\setluatexattribute
\let\luaModuleError\luatexModuleError
\let\luaRequireModule\luatexRequireModule
\let\luaUseModule\luatexUseModule

%    \end{macrocode}
%
%    Finally, we load \textsf{luaotfload}.
%
%    \begin{macrocode}

\expandafter\ifx\csname ProvidesPackage\endcsname\relax
  \input luaotfload.sty
\else
  \RequirePackage{luaotfload}
\fi

%    \end{macrocode}
% \iffalse
%</package>
% \fi
%
%
% \Finale
\endinput
